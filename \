use super::navigation_traits::WidgetNav;
use crate::docker_file_tree::{FileOp, TreeNode};
use crate::docker_image_utils::ImageLayer;
use crate::file_tree::{FileTree, FileTreeNode};
use ratatui::buffer::Buffer;
use ratatui::layout::Rect;
use ratatui::style::{Color, Modifier, Style};
use ratatui::text::Text;
use ratatui::widgets::StatefulWidget;
use std::cell::RefCell;
use std::collections::HashMap;
use std::path::PathBuf;
use std::rc::Rc;
use tui_tree_widget::{Tree, TreeItem, TreeState};

fn construct_items<'a>(layer: &'a ImageLayer, filter_str: &'a str) -> Vec<TreeItem<'a, PathBuf>> {
    // TODO:: think why this compiles without reference
    let tree = &layer.tree;
    let filtered_tree = tree.filter_tree_full_path(filter_str);
    // todo!("Implement the filter_tree_full_path function");
    // let tree = if let Some(filt_tree) = filtered_tree.as_ref() {
    //     filt_tree // Reference to the filtered tree
    // } else {
    //     &layer.tree // Reference to the original tree
    // };
    let (tree, error) = tree.filter_tree_full_path(filter_str);

    // parents at the start, children at the end
    let nodes_vec: Vec<Rc<RefCell<FileTreeNode>>> = tree.iter().collect();
    let root = tree.root();
    let mut map: HashMap<PathBuf, TreeItem<PathBuf>> = HashMap::new();

    for &node in nodes_vec.iter().rev() {
        if node == root {
            // Skip the root
            break;
        }
        let name = node.borrow().name();

        let path = node.borrow().path();

        let name: Text = match node.borrow().fop() {
            FileOp::Add => {
                let style = Style::new().fg(Color::Green);
                Text::styled(name, style)
            }
            FileOp::Remove => {
                let style = Style::new().fg(Color::Red);
                Text::styled(name, style)
            }
        };

        if node.borrow().get_n_children() == 0 {
            let leaf = TreeItem::new_leaf(path, name);
            map.insert(path, leaf);
        } else {
            let kids_paths = node.borrow().get_children_paths();
            // Because we are iterating in the reverse order of breadth-first search, we can assume that the children are already in the map
            let mut kids_items: Vec<TreeItem<PathBuf>> = Vec::new();
            for kid in kids_paths.iter() {
                let kid_item = map.remove(kid);
                match kid_item {
                    Some(item) => {
                        kids_items.push(kid_item);
                    },
                    None => {
                        unreachable!("Kid item that has been in the mapn is not found");
                    }
                }
                let tree_item =
                TreeItem::new(path.clone(), name, kids_items).expect("Can't create tree item");
                map.insert(node, tree_item);
        }
    }

    // All that should be left in the map are the nodes below the root

    let keys: Vec<TreeItem<PathBuf>> = map.into_values().collect();
    // sort by name
    // let mut keys = keys;
    // keys.sort_by(|a, b| a.identifier().cmp(b.identifier()));
    keys
}

/// A widget that displays a tree structure using searchbar state; This does not correspond to multiple strings
pub struct TreeBrowserWidgetState {
    search_string: String,
    tree_state: TreeState<String>,
}

impl TreeBrowserWidgetState {
    pub fn new(search_string: &str) -> Self {
        TreeBrowserWidgetState {
            search_string: search_string.to_string(),
            tree_state: TreeState::default(),
        }
    }

    pub fn expand(&mut self) {
        let selected_state = &mut self.tree_state;
        selected_state.toggle_selected();
    }

    pub fn set_search_string(&mut self, search_string: &str) {
        self.search_string = search_string.to_string();
    }
}

pub struct TreeBrowserWidget<'a> {
    corresponding_layer: &'a ImageLayer,
}

impl<'a> TreeBrowserWidget<'a> {
    pub fn new(layer: &'a ImageLayer) -> Self {
        TreeBrowserWidget {
            corresponding_layer: layer,
        }
    }
}

impl WidgetNav for TreeBrowserWidgetState {
    fn next(&mut self) {
        let selected_state = &mut self.tree_state;
        selected_state
            .select_relative(|current| current.map_or(0, |current| current.saturating_add(1)));
    }

    fn prev(&mut self) {
        let selected_state = &mut self.tree_state;
        selected_state
            .select_relative(|current| current.map_or(0, |current| current.saturating_sub(1)));
    }
}

impl<'a> StatefulWidget for TreeBrowserWidget<'a> {
    type State = TreeBrowserWidgetState;

    fn render(self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {
        let items = construct_items(self.corresponding_layer, &state.search_string);

        let tree_widget = Tree::new(&items)
            .expect("WTF")
            .highlight_style(
                Style::default()
                    .bg(Color::Blue)
                    .fg(Color::White)
                    .add_modifier(Modifier::BOLD),
            )
            .highlight_symbol(">> ");

        StatefulWidget::render(tree_widget, area, buf, &mut state.tree_state);
    }
}
